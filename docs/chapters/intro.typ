#import "../notes.typ"

= مقدمه

در بسیاری از زبان‌های برنامه‌سازی، 
#notes.note[کد منبع][source code]
تحت فرایندی به نام
#notes.note[ترجمه][compile] 
به کد زبان ماشین تبدیل می‌شود و نرم‌افزار به صورت کد زبان ماشین منتشر
و اجرا می‌شود. با این حال، کد زبان ماشین برای انسان خوانا نیست و برای
فهم نحوه عملکرد نرم‌افزار نیاز به کد منبع است. ترجمه معکوس فرایندی است
که در آن تلاش می‌شود از کد زبان ماشین خروجی یک مترجم، کد منبع بازیابی
شود.

به طور کلی کاربرد مترجم معکوس در زمینه مهندسی معکوس و به دست آوردن
کد منبع و نحوه عملکرد نرم‌افزارهایی است که به همراه کد منبع توزیع
نشده‌اند و کد منبع آن‌ها در دسترس نیست. به کمک ترجمه معکوس می‌توان
معادل کد منبعی که در دسترس نبود را به دست آورد و به کمک آن، نحوه
عملکرد نرم‌افزار را مطالعه کرد یا نسخه تغییریافته‌ای از آن را به وجود آورد.

یکی از کاربردهای مترجم معکوس در زمینه امنیت نرم‌افزار است و شرکت‌ها و
موسسات امنیتی روی بهبود مترجم‌های معکوس سرمایه گذاری کرده‌اند. مثلا
یکی از مترجم‌های مطرح پروژه
#notes.note[گیدرا][Ghidra]
است که توسط سازمان امنیت ملی امریکا توسعه داده شده است و به صورت
#notes.note[متن‌باز][Open Source]
در اختیار عموم قرار داده شده است. یا یک شرکت امنیتی به نام
#notes.note[اواست][Avast]
مترجم معکوس
#notes.note[رت‌دک][RetDec]
را توسعه داده است.
@RetDec
متخصصان امنیت نرم‌افزار به کمک ابزارهای مترجم معکوس می‌توانند بدافزارها
یا نرم‌افزارهای آسیب‌پذیر را مهندسی معکوس کرده و از طرز عملکرد آن‌ها
مطلع شوند.

یک کاربرد دیگر مترجم معکوس، بازیابی کدهای از دست رفته است. در صورتی
که به خوبی از یک کد منبع مراقبت نشود ممکن است به تدریج کدها
از بین بروند اما نسخه اجرایی آن‌ها که در حال استفاده است هنوز
وجود داشته باشد. در این صورت به کمک مترجم معکوس می‌توان کدهای از دست
رفته را به دست آورد. حتی در زمانی که یک نرم‌افزار توسط شرکت سازنده
آن رها شده است یا شرکت سازنده آن منحل شده است می‌تواند به کمک ترجمه معکوس
جان دوباره‌ای بگیرد و توسعه آن توسط افراد مستقل ادامه پیدا کند. استفاده
از مترجم معکوس در این زمینه برای نرم‌افزارها و به ویژه بازی‌های قدیمی
متداول است. البته در این نوع استفاده باید به رعایت قوانین حق تکثیر
نیز توجه کرد.

قابل توجه است که برای بسیاری از کاربردها، نیازی نیست که ترجمه معکوس
دقیقا کد ابتدایی که تحت فرایند ترجمه به کد ماشین فعلی تبدیل شده است
را به دست آورد و صرف این که یک کد خوانا و شبه انسانی در زبان سطح بالا
تولید کند که معادل کد ماشین داده شده باشد و در عین حال برای انسان
قابل فهم باشد کافی است.

با این حال حتی برای ایجاد یک کد خوانای معادل کد ماشین ورودی نیز چالش‌هایی
وجود دارد. مساله تشخیص کد خوانا از ناخوانا و تولید کد خوانا ذاتا یک
مساله خوش تعریف ریاضیاتی نیست و روش‌های سنتی که به صورت الگوریتمی
کار می‌کنند قادر به ارائه یک کد خوانا و انتخاب خواناترین کد از میان
چند گزینه نیستند. مثلا به صورت الگوریتمی نمی‌توان نام مناسبی را برای
یک متغیر انتخاب کرد. با ظهور شبکه‌های عصبی و مدل‌های زبانی بزرگ پیشرفت
بزرگی در درک زبان‌های طبیعی و ایجاد متن و کد با رعایت محدودیت‌های زبان
طبیعی به وجود آمده است. مثلا خوانایی یک کد می‌تواند با احتمال وقوع
آن در توزیع احتمالاتی یک مدل زبانی مدل سازی شود.

اگرچه مدل‌های زبانی بزرگ می‌توانند به صورت مستقیم و سرتاسر فرایند ترجمه
معکوس را انجام دهند، اما به دلیل ذات احتمالاتی آن‌ها، چالش‌هایی مانند
توهم برای آن‌ها وجود دارد. برای حل این مشکل، ما از ترکیب روش‌های
الگوریتمی و مدل زبانی استفاده می‌کنیم، به این صورت که به روش الگوریتمی
چند گزینه که همه آن‌ها معادل کد ورودی هستند را به دست می‌آوریم و به
کمک مدل زبانی خواناترین این گزینه‌ها را انتخاب می‌کنیم.
