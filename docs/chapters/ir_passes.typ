#import "../notes.typ"

= تبدیل زبان ماشین به نمایش میانی

در این قسمت زبان ماشین ریسک پنج به نمایش میانی ما تبدیل می‌شود. مهم‌ترین
کار انتخاب تایپ هاست چون نمایش میانی ما تایپ دارد و کد زبان ماشین
تایپ ندارد.

== طراحی نمایش میانی

نمایش میانی استفاده شده یک
#notes.note[گراف جریان کنترل][control flow graph]
است. گراف جریان کنترل یک داده‌ساختار شناخته شده در حوزه
طراحی مترجم‌هاست که با ساده‌سازی انجام گرفته شده بسیاری از تحلیل‌ها
را امکان‌پذیر می‌کند.

در نمایش میانی ما مثل همه گرافهای جریان کنترل تعدادی
#notes.note[بلوک ساده][basic block]
وجود دارد. این بلوک‌های ساده شامل تعدادی
#notes.note[دستور][statement]
و یک
#notes.note[خاتمه دهنده][terminator]
هستند که دستور‌ها به ترتیب اجرا می‌شود و تمام اتفاقات کنترلی
مثل شرط‌ها و پرش‌ها در خاتمه‌دهنده‌های یک بلوک انجام می‌شود.

=== تعریف بلوک ساده

نمایش میانی ما که یک گراف جریان کنترل است، در حقیقت گرافی است که
راس‌های آن بلوک‌های ساده و یال‌های آن خاتمه‌دهنده‌ها هستند. یال‌های این
گراف ساختارهای کنترلی موجود در برنامه را نشان می‌دهد. به این صورت
که یک اجرای یک تابع معادل یک گشت در گراف جریان کنترل خواهد بود. در
یک بلوک ساده تعدادی دستور و یک خاتمه دهنده وجود دارد. دستورها توانایی
انجام عملیات‌های کنترلی مثل پرش را ندارند و خط به خط به ترتیب اجرا می‌شوند
و صرفا می‌توانند مقادیری را از حافظه بخوانند یا بنویسند. در مقابل خاتمه دهنده‌ها
اجازه پرش به ابتدای بلوک‌های ساده دیگر را دارند.

این طراحی بلوک‌های ساده به بسیاری از تحلیل‌های روی برنامه کمک می‌کند تا از پیچیدگی
حاصل از پرش‌ها جلوگیری شود، به دلیل این که درون یک بلوک‌ساده هیچ پرشی وجود
ندارد و هیچ پرشی به وسط آن نیز انجام نمی‌شود بنابراین ما می‌توانیم در نظر بگیریم
که همه دستورهای یک بلوک ساده همواره اجرا می‌شوند. به دلیل این کمک، مترجم‌ها
از این نمایش گراف جریان کنترل به وفور استفاده می‌کنند. این خاصیت همان‌طور که در ادامه
می‌بینیم در تحلیل عملیات‌ها برای مترجم معکوس نیز فایده فراوانی خواهد داشت.

=== تعریف دستور

بر خلاف تعریف بلوک ساده که یک تعریف استاندارد و متداول در گراف‌های جریان کنترل
بود، در تعریف دستور تغییراتی به کار رفته شده که برای کاربرد مترجم معکوس مناسب‌تر
باشد.

یک دستور شامل مقداردهی یک مقدار درون یک مکان می‌باشد. مکان به صورت نوع استقرایی زیر
تعریف شده است:

```rust
pub enum Place {
    Local(Idx<Local>),
    Deref(Box<Place>),
    Offset(Box<Place>, Box<Value>),
}
```

مقدار نیز به صورت مشابه به صورت یک نوع استقرایی تعریف شده است:

```rust
pub enum Value {
    Place(Place),
    Literal(i32),
    Binop(Box<Value>, Binop, Box<Value>),
}
```

تفاوت اصلی تعاریف این جا از مقدار و مکان نسبت به تعاریف متداول‌تر این است
که مقدار و مکان به صورت بازگشتی تعریف شده‌اند. معمولا در مترجم‌ها این تعاریف
بازگشتی نیستند چون بازگشتی بودن آن‌ها باعث ایجاد پیچیدگی در تحلیل‌ها خواهد شد و
در کد ماشین نهایی ساختارهای بازگشتی وجود ندارند و در نتیجه تبدیل نمایش میانی به
کد ماشین سخت‌تر خواهد شد. مثلا
یک مترجم عبارت
`(1 + 2) * 3`
را به دو دستور تبدیل می‌کند که در دستور اول
`1 + 2`
در یک متغیر موقت ریخته شده و در دستور بعد نتیجه آن با
`3`
ضرب می‌شود. در مقابل در تعریف‌های بالا کل این عبارت می‌تواند به صورت یک مقدار
ذخیره شود.

این خاصیت به مترجم معکوس این امکان را می‌دهد تا نمایش‌های پیچیده‌تر و سطح بالاتری
از عبارت‌ها داشته باشد و عملیات‌های تعریف شده بتوانند حتی در این لایه خروجی سطح
بالاتری تولید کنند. این نمایش اگرچه تحلیل سطح داده را سخت‌تر می‌کند اما هم چنان
از نظر جریان کنترل ساده است و پیچیدگی‌های جریان کنترل را وارد کار نمی‌کند.

=== تعریف خاتمه‌دهنده

```rust
pub enum Terminator {
    Return,
    Goto { bb: Idx<BasicBlock> },
    If {
        cond: Value,
        then: Idx<BasicBlock>,
        else_: Idx<BasicBlock>,
    },
}
```

== انتخاب امضای توابع به کمک مدل زبانی

در نمایش میانی یک تابع به صورت تعدادی ورودی نوع‌دار، یک خروجی نوع‌دار، تعدادی
متغیر محلی نوع دار و تعدادی بلوک ساده نمایش داده می‌شود. برای ساخت
نمایش میانی از روی کد ماشین ورودی، به دانستن نوع‌های ورودی‌ها و خروجی
نیاز داریم. نوع متغیرهای محلی با دانستن نوع‌های ورودی و خروجی می‌تواند
استنتاج شود اما نوع‌های ورودی و خروجی بدون یک تحلیل تمام برنامه‌ای
قابل انجام نیست و بعضا حتی یک تحلیل تمام برنامه‌ای هم نمی‌تواند
یک نوع را به طور دقیق مشخص کند.

در این جاست که مدل زبانی می‌تواند
با توجه به حدس خود از نحوه کارکرد این برنامه و اطلاعات انسانی سطح
بالای باقی‌مانده مثل نام نماد‌ها، نوع‌های مناسبی را برای امضای تابع
تعیین کند. بررسی‌کننده الگوریتمی می‌تواند بررسی کند که این امضای
مشخص شده آیا با کد ماشین ورودی مطابقت دارد یا خیر. معمولا بسیاری
از نوع‌های متفاوت با امضای اصلی نیز قابل تطبیق هستند و بررسی الگوریتمی
اشتباهات کمی را می‌تواند تشخیص دهد، اما حتی اگر امضای تابع به اشتباه
تشخیص داده شود و توسط بررسی‌کننده الگوریتمی پذیرفته شود، این اشتباه
باعث تغییر در عملکرد خروجی نسبت به ورودی نخواهد شد و صرفا باعث
کاهش خوانایی کد خروجی خواهد شد.

=== ارزیابی مدل‌های زبانی مختلف در وظیفه بازیابی امضای تابع

== ساخت نمایش میانی از روی کد زبان ماشین

== بهبود نمایش میانی

=== عملیات‌های الگوریتمی

=== عملیات‌های مدل زبانی

در ابتدا چندین عمل برای چند کار مختلف برای واگذاری به مدل زبانی در نظر گرفته
شده بود. عمل‌هایی مانند:

- معکوس کردن تبدیل تقسیم به ضرب

اما این عمل‌ها از دو جهت مقیاس‌پذیر نبودند. اول این که هر عملیات نیاز به یک
پیاده‌سازی جداگانه برای تحلیل درستی نیاز داشت، و جهت دوم و مهم‌تر این که تمام
عملیات‌های مفید که توسط مدل زبانی قابلیت انجام دارند در عملیات‌های گفته شده
خلاصه نمی‌شوند.

بنابراین تصمیم گرفتیم که به جای همه این عملیات‌ها، عملیات عمومی جایگزینی تعدادی
دستور با تعدادی دستور معادل را استفاده کنیم. بر خلاف دو برنامه عمومی که بررسی
معادل بودن آن‌ها تصمیم پذیر نیست، درون یک بلوک ساده به علت عدم وجود ساختار‌های
کنترلی مانند حلقه، دستورها تورینگ کامل نیستند و برای بررسی معادل بودن دو مجموعه
دستور الگوریتم عمومی وجود دارد.

برای پیاده‌سازی بررسی برابری دو کد ما از یک ابزار
#notes.note[حل کننده صدق‌پذیری به پیمانه نظریات][Satisfiability modulo theorems solver]
به نام زد۳ استفاده کردیم. زد۳ توسط تیم تحقیقاتی مایکروسافت توسعه داده شده است
و برای تحلیل نرم‌افزارها از چندین تئوری مثل تئوری
#notes.note[اعداد ممیز شناور][floating point numbers]
یا تئوری
#notes.note[اعداد مکمل دو][two's complement numbers]
پشتیبانی می‌کند که برای کاربرد بررسی ما بسیار مفید است. از زد۳ در پروژه‌های بزرگ
صحت‌سنجی رسمی مثل دفنی، بوگی، پراستی و ... استفاده شده است.

=== بررسی عملیات‌های مدل زبانی با زد۳

برای صحت‌سنجی عملیات‌هایی که مدل زبانی روی مجموعه دستورهای یک بلوک ساده می‌تواند
انجام دهد، یک مجموعه دستور را درون زد۳ مدل می‌کنیم. مدل ما به این صورت است که
هر دستور یک تغییر در محیط ایجاد می‌کند. محیط شامل یک حافظه است که به صورت
مجموعه متناهی از بایت‌ها در نظر گرفته می‌شود و فهرستی از توابعی که تا به این لحظه
فراخوانی شده‌اند. هر دستور می‌تواند مقدارهایی را در حافظه تغییر دهد و چندین تابع
فراخوانی کند. اگر محیط به ازای هر مقدار اولیه از حافظه بعد از انجام دستورهای
اصلی با بعد از انجام دستورهای تغییریافته توسط مدل زبانی برابر بود، تغییری در رفتار
برنامه ایجاد نشده و مجموعه دستورات جدید می‌تواند پذیرفته شود.
