#import "../notes.typ"

= تبدیل زبان ماشین به نمایش میانی

در این قسمت زبان ماشین ریسک پنج به نمایش میانی ما تبدیل می‌شود. مهم‌ترین
کار انتخاب تایپ هاست چون نمایش میانی ما تایپ دارد و کد زبان ماشین
تایپ ندارد.

== طراحی نمایش میانی

نمایش میانی استفاده شده یک
#notes.note[گراف جریان کنترل][control flow graph]
است. گراف جریان کنترل یک داده‌ساختار شناخته شده در حوزه
طراحی مترجم‌هاست که با ساده‌سازی انجام گرفته شده بسیاری از تحلیل‌ها
را امکان‌پذیر می‌کند.

در نمایش میانی ما مثل همه گرافهای جریان کنترل تعدادی
#notes.note[بلوک ساده][basic block]
وجود دارد. این بلوک‌های ساده شامل تعدادی
#notes.note[دستور][statement]
و یک
#notes.note[خاتمه دهنده][terminator]
هستند که دستور‌ها به ترتیب اجرا می‌شود و تمام اتفاقات کنترلی
مثل شرط‌ها و پرش‌ها در خاتمه‌دهنده‌های یک بلوک انجام می‌شود.

=== تعریف بلوک ساده

نمایش میانی ما که یک گراف جریان کنترل است، در حقیقت گرافی است که
راس‌های آن بلوک‌های ساده و یال‌های آن خاتمه‌دهنده‌ها هستند. یال‌های این
گراف ساختارهای کنترلی موجود در برنامه را نشان می‌دهد. به این صورت
که یک اجرای یک تابع معادل یک گشت در گراف جریان کنترل خواهد بود. در
یک بلوک ساده تعدادی دستور و یک خاتمه دهنده وجود دارد. دستورها توانایی
انجام عملیات‌های کنترلی مثل پرش را ندارند و خط به خط به ترتیب اجرا می‌شوند
و صرفا می‌توانند مقادیری را از حافظه بخوانند یا بنویسند. در مقابل خاتمه دهنده‌ها
اجازه پرش به ابتدای بلوک‌های ساده دیگر را دارند.

این طراحی بلوک‌های ساده به بسیاری از تحلیل‌های روی برنامه کمک می‌کند تا از پیچیدگی
حاصل از پرش‌ها جلوگیری شود، به دلیل این که درون یک بلوک‌ساده هیچ پرشی وجود
ندارد و هیچ پرشی به وسط آن نیز انجام نمی‌شود بنابراین ما می‌توانیم در نظر بگیریم
که همه دستورهای یک بلوک ساده همواره اجرا می‌شوند. به دلیل این کمک، مترجم‌ها
از این نمایش گراف جریان کنترل به وفور استفاده می‌کنند. این خاصیت همان‌طور که در ادامه
می‌بینیم در تحلیل عملیات‌ها برای مترجم معکوس نیز فایده فراوانی خواهد داشت.

=== تعریف دستور

بر خلاف تعریف بلوک ساده که یک تعریف استاندارد و متداول در گراف‌های جریان کنترل
بود، در تعریف دستور تغییراتی به کار رفته شده که برای کاربرد مترجم معکوس مناسب‌تر
باشد.

یک دستور شامل مقداردهی یک مقدار درون یک مکان می‌باشد. مکان به صورت نوع استقرایی زیر
تعریف شده است:

```rust
pub enum Place {
    Local(Idx<Local>),
    Deref(Box<Place>),
    Offset(Box<Place>, Box<Value>),
}
```

مقدار نیز به صورت مشابه به صورت یک نوع استقرایی تعریف شده است:

```rust
pub enum Value {
    Place(Place),
    Literal(i32),
    Binop(Box<Value>, Binop, Box<Value>),
}
```

تفاوت اصلی تعاریف این جا از مقدار و مکان نسبت به تعاریف متداول‌تر این است
که مقدار و مکان به صورت بازگشتی تعریف شده‌اند. معمولا در مترجم‌ها این تعاریف
بازگشتی نیستند چون بازگشتی بودن آن‌ها باعث ایجاد پیچیدگی در تحلیل‌ها خواهد شد و
در کد ماشین نهایی ساختارهای بازگشتی وجود ندارند و در نتیجه تبدیل نمایش میانی به
کد ماشین سخت‌تر خواهد شد. مثلا
یک مترجم عبارت
`(1 + 2) * 3`
را به دو دستور تبدیل می‌کند که در دستور اول
`1 + 2`
در یک متغیر موقت ریخته شده و در دستور بعد نتیجه آن با
`3`
ضرب می‌شود. در مقابل در تعریف‌های بالا کل این عبارت می‌تواند به صورت یک مقدار
ذخیره شود.

این خاصیت به مترجم معکوس این امکان را می‌دهد تا نمایش‌های پیچیده‌تر و سطح بالاتری
از عبارت‌ها داشته باشد و عملیات‌های تعریف شده بتوانند حتی در این لایه خروجی سطح
بالاتری تولید کنند. این نمایش اگرچه تحلیل سطح داده را سخت‌تر می‌کند اما هم چنان
از نظر جریان کنترل ساده است و پیچیدگی‌های جریان کنترل را وارد کار نمی‌کند.

=== تعریف خاتمه‌دهنده

```rust
pub enum Terminator {
    Return,
    Goto { bb: Idx<BasicBlock> },
    If {
        cond: Value,
        then: Idx<BasicBlock>,
        else_: Idx<BasicBlock>,
    },
}
```

== انتخاب امضای توابع به کمک مدل زبانی

در نمایش میانی یک تابع به صورت تعدادی ورودی نوع‌دار، یک خروجی نوع‌دار، تعدادی
متغیر محلی نوع دار و تعدادی بلوک ساده نمایش داده می‌شود. برای ساخت
نمایش میانی از روی کد ماشین ورودی، به دانستن نوع‌های ورودی‌ها و خروجی
نیاز داریم. نوع متغیرهای محلی با دانستن نوع‌های ورودی و خروجی می‌تواند
استنتاج شود اما نوع‌های ورودی و خروجی بدون یک تحلیل تمام برنامه‌ای
قابل انجام نیست و بعضا حتی یک تحلیل تمام برنامه‌ای هم نمی‌تواند
یک نوع را به طور دقیق مشخص کند.

در این جاست که مدل زبانی می‌تواند
با توجه به حدس خود از نحوه کارکرد این برنامه و اطلاعات انسانی سطح
بالای باقی‌مانده مثل نام نماد‌ها، نوع‌های مناسبی را برای امضای تابع
تعیین کند. بررسی‌کننده الگوریتمی می‌تواند بررسی کند که این امضای
مشخص شده آیا با کد ماشین ورودی مطابقت دارد یا خیر. معمولا بسیاری
از نوع‌های متفاوت با امضای اصلی نیز قابل تطبیق هستند و بررسی الگوریتمی
اشتباهات کمی را می‌تواند تشخیص دهد، اما حتی اگر امضای تابع به اشتباه
تشخیص داده شود و توسط بررسی‌کننده الگوریتمی پذیرفته شود، این اشتباه
باعث تغییر در عملکرد خروجی نسبت به ورودی نخواهد شد و صرفا باعث
کاهش خوانایی کد خروجی خواهد شد.

=== ارزیابی مدل‌های زبانی مختلف در وظیفه بازیابی امضای تابع

== ساخت نمایش میانی از روی کد زبان ماشین

== بهبود نمایش میانی

=== عملیات‌های الگوریتمی

در ابتدا تمرکز روی فراهم کردن عملیات‌ها برای مدل زبانی بود اما با گذشت زمان دیدیم
که در بعضی حالت‌ها که خلاقیتی در ایجاد عملیات وجود ندارد، بررسی عملیات با انجام
آن از نظر پیاده‌سازی تفاوت چندانی ندارد و در نتیجه به جای این که از مدل زبانی
درخواست کنیم که این عملیات‌ها را انجام دهد که هم هزینه بر و هم غیر قابل اتکا
است، هرگاه که عملیات قابل انجام بود به صورت خودکار و بدون نظر مدل زبانی
آن را انجام دهیم. عملیات‌هایی که همواره به بهبود کد کمک می‌کنند و بدون نظر
مدل زبانی آن‌ها انجام می‌دهیم عبارت‌اند از:

- حذف متغیرهای محلی بدون استفاده: این عملیات به صورت ساده هر متغیر بدون
  استفاده‌ای را حذف می‌کند. معمولا این عملیات در آغاز قابل انجام نیست و بعد از
  یک عملیات دیگر قابل انجام می‌شود.
- برخط سازی مقداردهی متغیر: در صورتی که مقدار یک متغیر محلی در بلوک‌های ساده
  دیگر خوانده نشده باشد، و اشاره‌گری نیز به آن گرفته نشده باشد، مقداردهی به آن
  می‌تواند برخط شود و مقدار نوشته شده در آن با اسامی آن در دستورات بعد جایگزین
  شود و این دستور نوشتن حذف شود.

مجموعه این عملیات‌ها می‌تواند یک گراف جریان کنترل مانند زیر را:

```
fn sub {
    let _0: void
    let _1: *mut f64
    let _2: *mut f64
    let _3: i32
    let _4: bool
    let _5: i32
    let _6: f64
    let _7: f64
    let _8: *mut f64
    let _9: i64
    let _10: i32
    let _11: f64
    let _12: *mut f64
    let _13: i64
    let _14: i32
    let _15: i32
    let _16: f64
    let _17: *mut f64
    let _18: i64
    let _19: i32
    let _20: *mut f64
    let _21: i64
    let _22: i32
    bb0: {
        _3 = 0;
        _3 = 0;
        goto bb1;
    }
    bb1: {
        _5 = _3;
        _4 = _5 < 3;
        if _4 { goto bb2 } else { goto bb3 }
    }
    bb2: {
        _10 = _3;
        _9 = _10;
        _8 = _1.offset(_9);
        _7 = *_8;
        _15 = _3;
        _14 = 3 + _15;
        _13 = _14;
        _12 = _2.offset(_13);
        _11 = *_12;
        _6 = _7 / _11;
        _19 = _3;
        _18 = _19;
        _17 = _2.offset(_18);
        _16 = *_17;
        _22 = _3;
        _21 = _22;
        _20 = _1.offset(_21);
        *_20 = _6 + _16;
        _3 = _3 + 1;
        goto bb1;
    }
    bb3: {
        return;
    }
}
```

به گراف جریان کنترل زیر ساده‌سازی کند:

```
fn sub {
    let _0: *mut f64
    let _1: *mut f64
    let _2: i32
    bb0: {
        _2 = 0;
        _2 = 0;
        goto bb1;
    }
    bb1: {
        if _2 < 3 { goto bb2 } else { goto bb3 }
    }
    bb2: {
        *_0.offset(_2) = *_0.offset(_2) / *_1.offset(3 + _2) + *_1.offset(_2);
        _2 = _2 + 1;
        goto bb1;
    }
    bb3: {
        return;
    }
}
```

همان طور که می‌بینید این ساده‌سازی ایده‌آل نیست و هم‌چنان مدل زبانی می‌تواند آن را
بهبود دهد ولی نسبت به نسخه اولیه بسیاری از کار‌ها را انجام می‌دهد.

این عملیات‌های الگوریتمی نیز در ابتدا عملیات‌هایی بودند که مدل زبانی باید آن‌ها
را انتخاب می‌کرد و انجام می‌داد ولی به علت این که عملیات به سادگی قابل انجام
نبود و مدل‌های زبانی از تمام توان این عملیات‌ها نمی‌توانستند استفاده کنند و
هم‌چنین این که استفاده از این عملیات‌ها همواره باعث افزایش خوانایی برنامه
می‌شد، تصمیم گرفته شد تا این قسمت بدون مدل زبانی انجام شود.

=== عملیات‌های مدل زبانی

در ابتدا چندین عمل برای چند کار مختلف برای واگذاری به مدل زبانی در نظر گرفته
شده بود. عمل‌هایی مانند:

- معکوس کردن تبدیل تقسیم به ضرب
- تغییرات جبری مثل جایگزینی `a+a` با `2*a`
- افزودن متغیرهای موقت اضافی


اما این عمل‌ها از دو جهت مقیاس‌پذیر نبودند. اول این که هر عملیات نیاز به یک
پیاده‌سازی جداگانه برای تحلیل درستی نیاز داشت، و جهت دوم و مهم‌تر این که تمام
عملیات‌های مفید که توسط مدل زبانی قابلیت انجام دارند در عملیات‌های گفته شده
خلاصه نمی‌شوند.

بنابراین تصمیم گرفتیم که به جای همه این عملیات‌ها، عملیات عمومی جایگزینی تعدادی
دستور با تعدادی دستور معادل را استفاده کنیم. بر خلاف دو برنامه عمومی که بررسی
معادل بودن آن‌ها تصمیم پذیر نیست، درون یک بلوک ساده به علت عدم وجود ساختار‌های
کنترلی مانند حلقه، دستورها تورینگ کامل نیستند و برای بررسی معادل بودن دو مجموعه
دستور الگوریتم عمومی وجود دارد.

برای پیاده‌سازی بررسی برابری دو کد ما از یک ابزار
#notes.note[حل کننده صدق‌پذیری به پیمانه نظریات][Satisfiability modulo theorems solver]
به نام زد۳ استفاده کردیم. زد۳ توسط تیم تحقیقاتی مایکروسافت توسعه داده شده است
و برای تحلیل نرم‌افزارها از چندین تئوری مثل تئوری
#notes.note[اعداد ممیز شناور][floating point numbers]
یا تئوری
#notes.note[اعداد مکمل دو][two's complement numbers]
پشتیبانی می‌کند که برای کاربرد بررسی ما بسیار مفید است. از زد۳ در پروژه‌های بزرگ
صحت‌سنجی رسمی مثل دفنی، بوگی، پراستی و ... استفاده شده است.

=== بررسی عملیات‌های مدل زبانی با زد۳

برای صحت‌سنجی عملیات‌هایی که مدل زبانی روی مجموعه دستورهای یک بلوک ساده می‌تواند
انجام دهد، یک مجموعه دستور را درون زد۳ مدل می‌کنیم. مدل ما به این صورت است که
هر دستور یک تغییر در محیط ایجاد می‌کند. محیط شامل یک حافظه است که به صورت
مجموعه متناهی از بایت‌ها در نظر گرفته می‌شود. هر
دستور می‌تواند مقدارهایی را در حافظه تغییر دهد. اگر محیط به ازای هر
مقدار اولیه از حافظه بعد از انجام دستورهای
اصلی با بعد از انجام دستورهای تغییریافته توسط مدل زبانی برابر بود، تغییری در رفتار
برنامه ایجاد نشده و مجموعه دستورات جدید می‌تواند پذیرفته شود.

حافظه در زد۳ معمولا به صورت تعدادی بلوک از بایت نگهداری می‌شود اما
در این جا ما به صورت یگ آرایه خطی از بایت آن را تعریف
کرده‌ایم. عیب این کار این است که با این مدل سازی هر نوشتن روی حافظه
توسط یک اشاره‌گر می‌تواند کل حافظه را به هم بریزد و محدود به یک تخصیص خاص
از حافظه نیست. با این حال چون کد ما از یک کد زبان سی ساخته نشده است و
استفاده از یک اشاره‌گر برای دسترسی به بقیه حافظه
#notes.note[رفتار تعریف نشده][undefined behavior]
نیست، ما مجبوریم که حافظه را به صورت یک آرایه بزرگ از بایت‌ها تعریف کنیم.

به هر متغیر محلی یک آدرس می‌دهیم که محل آن در حافظه را ذخیره می‌کند، سپس
در هر دستور آدرس مکانی که روی آن نوشته می‌شود و مقدار را به
بیت‌وکتور که داده ساختار تعریف‌شده در زد۳ برای عملیات‌های مکمل دو است تبدیل
می‌کند و سپس آن را به قطعات به اندازه بایت تبدیل می‌کند و روی حافظه می‌نویسد.

مثلا برای معکوس کردن عمل تبدیل تقسیم به ضرب اگر دستور
```
_0 = _1 / 10
```
را داشته باشیم و آدرس متغیر محلی صفرم برابر
`0x00000000000003e8`
و آدرس متغیر محلی اول برابر
`0x00000000000003e8`
باشد مقدار حافظه بعد از اجرای این دستور با عبارت زیر در زد۳ مدل‌سازی می‌شود:

#text(size: 10pt)[

  ```
  (let value!1 (concat (concat (concat (select memory!0 #x00000000000003e8)
                          (select memory!0
                                  (bvadd #x00000000000003e8 #x0000000000000001)))
                  (select memory!0 (bvadd #x00000000000003e8 #x0000000000000002)))
          (select memory!0 (bvadd #x00000000000003e8 #x0000000000000003))))
  (let value!3 (bvsdiv value!1 #x0000000a))
  (store (store (store (store memory!0
                              (bvadd #x00000000000003e8 #x0000000000000000)
                              ((_ extract 7 0) value!3))
                       (bvadd #x00000000000003e8 #x0000000000000001)
                       ((_ extract 15 8) value!3))
                (bvadd #x00000000000003e8 #x0000000000000002)
                ((_ extract 23 16) value!3))
         (bvadd #x00000000000003e8 #x0000000000000003)
         ((_ extract 31 24) value!3))
  ```

]

در این عبارت ابتدا متغیر محلی یکم از حافظه به صورت بایت به بایت بارگیری می‌شود، سپس
تقسیم علامت دار با تابع
`bvsdiv`
روی مقدار بارگیری شده و ده اجرا می‌شود، و در نهایت مقدار خروجی به صورت بایت
به بایت در حافظه ذخیره می‌شود و یک حافظه جدید به وجود می‌آید.

به صورت مشابه این کار برای نسخه شامل ضرب و شیفت بیتی انجام می‌شود، و در نهایت از
زد۳ خواسته می‌شود تا ثابت کند این دو نسخه با هم برابرند. در صورتی که زد سه قادر به
اثبات این موضوع باشد، این تغییر دستورات که در این جا تبدیل ضرب به تقسیم است
از مدل زبانی پذیرفته می‌شود.

=== محدودیت‌های عملیات‌های مدل زبانی

اگرچه بررسی برابری دو مجموعه دستور یک مساله تصمیم‌پذیر است و برای بررسی آن
الگوریتم وجود دارد اما زمان اجرای این الگوریتم در بدترین حالت بسیار زیاد
است. یک الگوریتم بدیهی برای حل این مساله این است که به ازای تمام حالت‌های
حافظه برابری دو مجموعه دستورالعمل را بررسی کنیم اما این کار دو بتوان دو بتوان
شصت و چهار بررسی نیاز دارد. اگرچه زد۳ بسیار هوشمندانه تر از این کار عمل می‌کند و در بسیاری از مواقع در کسری از ثانیه می‌تواند برابری را ثابت کند، اما حالت‌های پیچیده‌ای
وجود دارند که زد۳ قادر به حل آن‌ها نیست. در این مواقع زد۳ شروع به امتحان کردن
حالت‌های مختلف می‌کند و کار را خاتمه نمی‌دهد. برای مختل نشدن فرایند
برای بررسی زد۳ یک تایم اوت گذاشتیم که بعد از گذشت آن بررسی را با نتیجه شکست
خاتمه می‌دهد.

به کمک تایم‌اوت می‌توان مانع اختلال در عملکرد مترجم معکوس شد، اما ممکن است
بعضی از تغییرات درست نیز دچار تایم‌اوت شوند. مثلا در همین مثال تبدیل ضرب
به تقسیم، زد۳ به تنهایی قادر به اثبات این قضیه نیست و چون مثال نقضی نیز
برای آن وجود ندارد، دچار تایم اوت می‌شود. با افزودن قضیه‌های کمکی می‌توان
به زد۳ برای اثبات درستی تغییرات کمک کرد. مثلا در همین مثال تبدیل ضرب به تقسیم، اگر قضیه زیر را به زد۳ اضافه کنیم

```
(assert (forall ((x (_ BitVec 32))) (=
    (bvsdiv x #x0000000a)
    (bvsub
        ((_ extract 31 0) (bvashr
        (bvmul ((_ zero_extend 32) x) ((_ zero_extend 32) #x66666667))
        ((_ zero_extend 32) #x00000022)))
        (bvashr x #0000001f)
    )))

```

در این صورت زد۳ می‌تواند در کسری از ثانیه درستی عملیات معکوس تقسیم به ضرب
را ثابت کند. این قضیه و چندین قضیه دیگر در هر نشست به زد۳ داده می‌شود و
به زد۳ برای اثبات درستی عملیات‌های به کار رفته توسط مدل زبانی کمک می‌کند. با این حال
این موضوع که هر قضیه باید به صورت دستی به فهرست قضایا اضافه شود عام منظوره بودن
این عملیات را از جهاتی بی‌فایده می‌کند.

یک راه حل برای این مساله،در نظر گرفتن تایم اوت به عنوان پذیرفته شده است. معمولا
هنگامی یک تغییر توسط مدل زبانی
دچار تایم اوت می‌شود در آزمایشات صورت گرفته به این صورت بوده است که تغییر
درست بوده ولی زد۳ قادر به اثبات این تغییر نبوده و تلاش به امتحان کردن
همه حالت‌های ممکن کرده است و در میلیون‌ها حالتی که در حین رسیدن به زمان تایم اوت بررسی کرده مثال نقضی پیدا نکرده است. به همین دلیل یک تنظیم برای سیستم ما این است
که هنگام تایم اوت تغییر را قبول کنیم. این تنظیم آنساوند است و درستی ریاضیاتی کد
را تحت الشعاع قرار می‌دهد اما برای کاربردهای عملی ممکن است مفید باشد.


