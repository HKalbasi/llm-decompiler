#set text(
  font: "Vazirmatn",
  lang: "fa",
)

= معماری لایه‌ای معکوس

== معماری لایه‌ای در مترجم‌ها

به طور کلی 

1. *Frontend (جلوی کامپایلر)*  
2. *Middle-End / Optimizer (بهینه‌ساز میانی)*  
3. *Backend / Code Generator (مولد کد)*

هر بخش به‌صورت ماژول مستقل طراحی شده و ارتباط میان آن‌ها از طریق LLVM IR انجام می‌شود.

== Frontend
Frontend وظیفهٔ تبدیل زبان سطح بالا به LLVM IR را دارد.  
به‌عنوان مثال، کامپایلر Clang ابتدا کد C/C++ را تحلیل نحوی کرده، AST می‌سازد و سپس آن را به LLVM IR تبدیل می‌کند.

Frontend شامل مراحل زیر است:
- تحلیل لغوی و نحوی (Lexing / Parsing)  
- ساخت درخت نحو انتزاعی (AST)  
- تحلیل معنایی و نوع‌دهی  
- تولید LLVM IR

== Middle-End (Optimizer)
بخش بهینه‌ساز یا *middle-end* روی LLVM IR کار می‌کند.  
در این مرحله، مجموعه‌ای از «پَس‌ها» (*passes*) اجرا می‌شوند که هرکدام تحلیل یا تبدیل خاصی روی IR انجام می‌دهند.

ویژگی‌های اصلی طراحی:
- هر پاس به‌صورت ماژول مستقل پیاده‌سازی شده است.  
- *Pass Manager* مسئول اجرای ترتیبی و مدیریت وابستگی میان پاس‌هاست.  
- بهینه‌سازی‌ها می‌توانند در سطوح مختلف انجام شوند: SSA، حلقه، جریان داده، و غیره.

نمونه‌هایی از پاس‌ها:
- *Constant Propagation*  
- *Dead Code Elimination*  
- *Loop Invariant Code Motion*  
- *Inlining*  
- *Vectorization*

LLVM به‌صورت پیش‌فرض مجموعه‌ای از pipelineهای آماده برای سطوح مختلف بهینه‌سازی دارد (مثلاً ‎`-O1`, `-O2`, `-O3`).

== Backend (Code Generator)
بخش Backend وظیفهٔ تولید کد اسمبلی یا باینری برای معماری هدف را بر عهده دارد.  
این بخش از طراحی ماژولار استفاده می‌کند و شامل اجزای زیر است:

- *TargetMachine*: رابط اصلی معماری هدف  
- *TargetInstrInfo*: اطلاعات مربوط به دستورها  
- *TargetRegisterInfo*: اطلاعات ثبات‌ها  
- *TargetFrameLowering*: مدیریت پشته و پروتکل‌های تابع  

مراحل کلی در backend:
1. انتخاب دستور (*Instruction Selection*) با استفاده از ساختار *SelectionDAG*  
2. زمان‌بندی دستورها (*Instruction Scheduling*)  
3. تخصیص ثبات‌ها (*Register Allocation*)  
4. درج پیش‌کدها و پس‌کدهای تابع (*Prologue/Epilogue Insertion*)  
5. بهینه‌سازی سطح ماشین (*Machine-level Peephole Optimizations*)  
6. تولید اسمبلی یا کد باینری نهایی

== طراحی مدولار
LLVM به‌صورت کتابخانه‌ای طراحی شده است. هر بخش (frontend، optimizer، backend) می‌تواند به‌صورت مستقل استفاده یا جایگزین شود.  
این باعث می‌شود توسعه‌دهندگان بتوانند:
- Frontend جدید برای زبان‌های خاص بسازند.  
- Backend جدید برای معماری‌های سفارشی اضافه کنند.  
- از زیرساخت IR و optimizer در ابزارهای تحلیل استاتیک یا JIT استفاده کنند.

== فایل‌های TableGen
LLVM برای تعریف ساختار معماری‌ها، ثبات‌ها، و دستورها از سیستم *TableGen* استفاده می‌کند.  
توصیف‌ها در فایل‌های `.td` نوشته می‌شوند و سپس به کد C++ مولد backend ترجمه می‌شوند.

== LLVM IR و Bitcode
LLVM IR می‌تواند در دو شکل ذخیره شود:
- *متنی (human-readable)*  
- *باینری (bitcode)*  

ابزارهایی مانند `llvm-as` و `llvm-dis` امکان تبدیل بین این دو را فراهم می‌کنند.  
Bitcode در پروژه‌هایی مانند *Clang* و *Emscripten* برای توزیع و بازاستفاده از کد میانی کاربرد دارد.

== سیستم پاس‌ها
بهینه‌سازی‌ها در LLVM بر پایهٔ مفهوم *Pass* بنا شده‌اند.  
هر پاس یا *Analysis Pass* است (که فقط اطلاعات محاسبه می‌کند) یا *Transform Pass* (که کد را تغییر می‌دهد).  
*Pass Manager* تضمین می‌کند که پاس‌ها به ترتیب درست و بدون اجرای مجدد بی‌مورد اجرا شوند.

== توسعه‌های جدید
در سال‌های اخیر LLVM پروژهٔ *MLIR (Multi-Level IR)* را معرفی کرده است.  
MLIR امکان کار در سطوح بالاتر انتزاعی را فراهم می‌کند و به تدریج به LLVM IR نهایی پایین آورده می‌شود.  
این مدل برای هوش مصنوعی و GPU-targets بسیار مفید است.

== جمع‌بندی
طراحی واقعی LLVM بر مبنای اصول زیر است:
- جداسازی کامل frontend، optimizer و backend  
- استفاده از IR به‌عنوان رابط مشترک  
- طراحی کتابخانه‌ای و قابل ترکیب  
- پشتیبانی از پاس‌های مستقل برای تحلیل و تبدیل  
- قابلیت هدف‌گیری چندین معماری با حداقل تغییرات  

این معماری LLVM را به یکی از موفق‌ترین و گسترده‌ترین زیرساخت‌های کامپایلری جهان تبدیل کرده است.

