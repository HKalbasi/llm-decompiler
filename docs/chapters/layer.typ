#import "../notes.typ"

= معماری لایه‌ای معکوس

در این فصل به بررسی معماری کلی مترجم معکوس ارائه شده می‌پردازیم و
معماری قبل از آن که به موفقیت نرسید را به همراه دلایل
عدم موفقیت بررسی
می‌کنیم. معماری مترجم معکوس ارائه شده یک معماری لایه‌ای
است که معکوس شده معماری لایه‌ای متداول به کار رفته در
مترجم‌هاست.

== معماری لایه‌ای در مترجم‌ها

به طور کلی همه مترجم‌های مدرن به صورت لایه‌ای عمل می‌کنند
و هیچ مترجم صنعتی
به صورت تک‌عبوری از کد منبع کد زبان ماشین
نمی‌سازد.
@dragon
به صورت کلی مترجم‌های امروزی حداقل سه لایه زیر را دارند:

1. لایه پیشین: تجزیه ورودی
2. لایه میانی: بهینه‌سازی
3. لایه پسین: ساخت کد ماشین

در هر لایه کد منبع به صورت یک نمایش میانی در می‌آید و به لایه‌های بعدی فرستاده
می‌شود.

=== لایه پیشین
لایه پیشین وظیفه پردازش زبان سطح بالا و تبدیل آن به یک نمایش
میانی را دارد.
به‌عنوان مثال، کامپایلر Clang ابتدا کد C/C++ را تحلیل نحوی کرده، AST می‌سازد و سپس آن را به LLVM IR تبدیل می‌کند.

لایه پیشین مترجم‌ها معمولا شامل مراحل زیر است:
- تحلیل لغوی و نحوی (Lexing / Parsing)
- ساخت درخت نحو انتزاعی (AST)
- تحلیل معنایی و نوع‌دهی
- تولید LLVM IR

=== لایه میانی
بخش بهینه‌ساز یا لایه میانی روی نمایش میانی ساخته شده توسط لایه پیشین کار می‌کند.
در این مرحله، مجموعه‌ای از عبورها اجرا می‌شوند که هرکدام تحلیل یا تبدیل خاصی روی
نمایش میانی انجام می‌دهند.

ویژگی‌های متداول در طراحی عبورها:
- هر عبور به‌صورت مستقل از بقیه عبورها عمل می‌کند و می‌تواند فعال یا غیرفعال
  شود. اگرچه ممکن است یک عبور به اطلاعات به دست آمده از یک عبور تحلیلی دیگر
  نیاز داشته باشد.
- در هر عبور ممکن است به یک نوع بهنجار شده از نمایش میانی نیاز داشته باشیم
  و بعضی از بهینه‌سازی‌ها فقط روی این نوع کار کنند. در این صورت باید عبوری که این
  بهنجار سازی را انجام می‌دهد قبل از عبور فعلی انجام گرفته باشد.

نمونه‌هایی از عبورهایی که در اکثر مترجم‌ها پیاده‌سازی شده است:
- *Constant Propagation*
- *Dead Code Elimination*
- *Loop Invariant Code Motion*
- *Inlining*
- *Vectorization*

=== لایه پسین
بخش پسین وظیفه تولید کد ماشین برای معماری هدف را بر عهده دارد.
این بخش از طراحی ماژولار استفاده می‌کند و شامل اجزای زیر است:

- *TargetMachine*: رابط اصلی معماری هدف
- *TargetInstrInfo*: اطلاعات مربوط به دستورها
- *TargetRegisterInfo*: اطلاعات ثبات‌ها
- *TargetFrameLowering*: مدیریت پشته و پروتکل‌های تابع

مراحل کلی در backend:
1. انتخاب دستور (*Instruction Selection*) با استفاده از ساختار *SelectionDAG*
2. زمان‌بندی دستورها (*Instruction Scheduling*)
3. تخصیص ثبات‌ها (*Register Allocation*)
4. درج پیش‌کدها و پس‌کدهای تابع (*Prologue/Epilogue Insertion*)
5. بهینه‌سازی سطح ماشین (*Machine-level Peephole Optimizations*)
6. تولید اسمبلی یا کد باینری نهایی

== مزایای طراحی لایه‌ای

=== گسترش ساده به زبان‌ها و معماری های دیگر

یک مزیت کلیدی تبدیل به نمایش میانی این است که بهینه‌سازی‌ها
یک بار می‌تواند روی نمایش میانی انجام شود و بعد از انجام
عمده بهینه‌سازی‌ها کد به زبان ماشین تبدیل شود. به این ترتیب
برای اضافه کردن پشتیبانی از ماشین‌های متفاوت نیازی به
پیاده‌سازی مجدد همه بهینه‌سازی‌ها نیست و کافیست که صرفا
مبدل نمایش میانی به زبان ماشین نوشته شود.
@lattner2004llvm

به طور مشابه، به کمک نمایش میانی می‌توان برای زبان‌های
سطح بالای متفاوت مترجم نوشت ولی قسمت بهینه‌سازی
و تولید زبان ماشین را بین آن‌ها
استفاده مشترک کرد.
@lattner2004llvm
به این صورت که مترجم زبان سطح بالا به جای تبدیل کد به
زبان ماشین به صورت مستقیم، آن را به نمایش میانی تبدیل
می‌کند.

#image("image.png")

به این ترتیب بهینه‌ساز می‌تواند یک بار به ازای همه زبان‌ها
و همه معماری‌ها نوشته شود، و ساخت زبان ماشین می‌تواند
به جای این که یک بار به ازای هر زبان سطح بالا نوشته شود
در کل یک بار نوشته شود. با این کار زبان‌های
سطح بالای جدید می‌توانند
بدون صرف هزینه زیاد روی تعداد زیادی ماشین متنوع اجرا شوند
و یک ماشین با معماری جدید نیز می‌تواند از زبان‌های سطح
بالای زیادی با هزینه اندک پشتیبانی کند.

=== پیاده سازی راحت‌تر تحلیل‌ها روی نمایش میانی

معمولا نمایش میانی مترجم‌ها از کد سطح بالا بسیار ساده‌تر است
و پیجیدگی‌های زبان سطح بالا در هنگام تبدیل به نمایش میانی
از بین می‌رود. مثلا در نمایش میانی معمولا به جای ساختارهای
کنترلی سطح بالا مثل حلقه‌ها از
#notes.note[گراف جریان کنترل][Control flow graph]
استفاده می‌کند. در گراف جریان کنترل بسیاری از تحلیل‌های
کنترلی مثل این که آیا یک نقطه در اجرای نقطه دیگر
تاثیر می‌گذارد و ممکن است قبل از آن اجرا شود
با یک الگوریتم ساده گراف قابل تصمیم‌گیری است.

یک ساده‌سازی دبگر که در نمایش میانی مترجم‌ها استفاده
می‌شود، استفاده از
صورت
#notes.note[تک مقداردهی ایستا][Static single assignment]
است. در این نمایش هر متغیر به جز متغیرهای خاص دقیقا
یک بار مقدار می‌گیرد و این ویژگی بسیاری از تحلیل‌ها را
ساده می‌کند. مثلا در مثال زیر
```
y := 1
y := 2
x := y
```
برای یک انسان واضح است که مقداردهی دوم هیچ تاثیری ندارد
اما در یک مترجم این تغییر نیاز به یک بهینه‌سازی
پیچیده دارد. با این حال در صورت تک مقدار دهی
```
y1 := 1
y2 := 2
x1 := y2
```
تشخیص این موضوع حتی برای مترجم نیز آسان می‌شود.


== طراحی لایه‌ای مترجم معکوس

برای انجام دادن فرایند معکوس ترجمه، یک انتخاب طبیعی این است که ترجمه معکوس
دقیقا برعکس ترجمه عادی را طی کند. یعنی ابتدا کد ماشین به نمایش میانی مترجم
ترجمه معکوس شود، سپس چند عمل که معکوس عمل‌های بهینه‌سازی هستند مثل
de-inline
کردن توابع روی این نمایش میانی انجام شود، سپس کد سطح بالا از روی نمایش میانی
گسترش یافته تولید شود.

== مزایای طراحی لایه‌ای مترجم معکوس

طراحی لایه‌ای مترجم معکوس دقیقا همان مزایای طراحی لایه‌ای مترجم به مترجم می‌دهد را
به مترجم معکوس می‌دهد.

=== گسترش ساده به زبان‌ها و معماری‌های دیگر

اگرچه در این کار صرفا از زبان سی و معماری ریسک پنج پشتیبانی می‌شود اما معماری لایه‌ای
این امکان را می‌دهد تا در ادامه از معماری‌های دیگر مثل ایکس هشتاد و شش و از زبان‌های
دیگر مثل راسط نیز پشتیبانی شود.

=== پیاده‌سازی راحت‌تر تحلیل‌ها روی نمایش میانی

دلیل انتخاب رویکرد لایه‌ای و تغییر پیاده‌سازی قبلی این بود که امکان تحلیل عملیات‌ها
روی کد سطح بالا تقریبا وجود نداشت. برای
صحت‌سنجی و اعمال تغییرات در کد سطح بالا، پیچیدگی زیادی وجود داشت و همین پیچیدگی
باعث می‌شد تا پروژه به سمت انتخاب عمل‌های ساده‌تر و ضعیف‌تر متمایل شود که در نتیجه
باعث محدود شدن کیفیت خروجی شود.

با استفاده از معماری لایه‌ای و انجام بعضی از عملیات‌ها روی نمایش‌های میانی که ساده‌تر
هستند و با الگوریتم‌های شناخته شده تحلیل می‌شوند، می‌توان این مشکل را رفع کرد و
عملیات‌های پیجیده‌تری را برای کار مدل‌های زبانی تعریف کرد.

== پیاده‌سازی شکست خورده غیر لایه‌ای

قبل از معماری لایه‌ای فعلی، یک معماری ساده‌تر غیر لایه‌ای به کار گرفته می‌شد. در آن
معماری کد ماشین ورودی توسط یک مترجم معکوس الگوریتمی به یک کد به زبان سی ولی
ناخوانا تبدیل می‌شد و این کد سی به مدل زبانی ورودی داده می‌شد. برای مدل زبانی
چند عمل تعریف شده بود که همه عمل‌ها در دامنه زبان سی بودند و یک کد زبان سی
را به یک کد دیگر تبدیل می‌کردند.

برای تعیین این عمل‌ها و آزمون و خطا برای انتخاب عمل‌های خوب، که همان‌طور که
گفته شد تاثیر زیادی در عملکرد نهایی دارد، عمل‌های زیر امتحان شدند:

- افزودن نظر
- تغییر نام یک متغیر
- درون‌خط سازی یک مقداردهی
- حذف متغیر زائد
- تبدیل یک ورودی خوانده نشده به یک متغیر محلی
- تبدیل ضرب و شیفت به تقسیم
- تبدیل عدد به کاراکتر
- تبدیل پرش به حلقه
- درون‌خط سازی پرش
- تغییر نوع متغیر

در گام اول، انجام و بررسی درستی این عمل‌ها به خود مدل زبانی سپرده شد. مدل زبانی
متاسفانه در رعایت عمل‌ها و تولید خروجی متناسب با یک عمل موفق نبود و در یک
عمل کارهای دیگری را نیز انجام می‌داد و در بعضی مواقع کد را به کلی عوض می‌کرد. در
نتیجه حتی برای آزمایش این که مدل زبانی چقدر می‌تواند از این عمل‌ها به خوبی
استفاده کند نیازمند پیاده‌سازی الگوریتمی عملیات‌ها بودیم.

برای انجام یا صحت‌سنجی این عملیات‌ها، حتی عملیات‌هایی که نسبتا
ساده‌تر به نظر می‌رسند، روش‌های ساده متنی کافی نیست. مثلا برای پیاده‌سازی عمل تغییر
نام، نمی‌توان به صورت متنی همه نام‌ها را جایگزین کرد چون در زبان سی قابلیت
سایه‌کردن و استفاده مجدد از نام‌ها را می‌دهد و نام دوباره استفاده شده لزوما
نباید تغییر کند.

بنابراین برای انجام عمل‌ها به تحلیل‌های الگوریتمی نیاز داریم. همان‌طور که مطرح شد
تحلیل روی نمایش‌های میانی ساده تر است و در نتیجه در هر عمل، باید کد به نمایش‌های
ساده‌تر تبدیل شود و عمل روی آن نمایش‌ها انجام شود، و سپس مجددا کد از روی آن عملیات‌ها
ساخته شود.

#align(center, text(size: .8em, [

  #figure(
    image("../images/go_back_and_forth.drawio.svg", width: 80%),
  )

  *شکل 2:* انجام عملیات‌ها روی کد سی نیاز به جابه‌جایی مداوم بین کد
  سطح بالا و نمایش‌های میانی دارد.

]))

متاسفانه تبدیل کد سی سطح بالا به نمایش میانی قابل تحلیل یک عملیات بدون
از دست دادن داده نیست، و از نمایش میانی نمی‌توان به طور کامل
کد سطح بالای اصلی را بازیابی کرد. اگرچه تحقیقاتی برای انجام این کار
صورت گرفته است و در این زمینه کاربردهایی مثل انجام ریفاکتور در
محیط‌های توسعه و ابزارها وجود دارد، اما دقت این ابزارها محدود است
و بیشتر آن‌ها به دخالت یا نظارت
انسانی نیاز دارند. برای کاربرد مترجم معکوس نیازی به
این رفت و برگشت وجود ندارد. در مترجم معکوس ما از یک کد سطح پایین زبان
ماشین شروع می‌کنیم، و می‌توانیم به صورت مرحله به مرحله
این کار را انجام دهیم و در همان سطوح میانی عملیات‌ها را انجام دهیم و
بعد از انجام همه عملیات‌ها کد سطح بالا را بسازیم.

به طور خاص پیچیدگی انجام تبدیل‌های مرتبط با پرش باعث کنار گذاشته شدن این
روش و استفاده از روش لایه‌ای شد.
