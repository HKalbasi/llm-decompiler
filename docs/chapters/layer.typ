= معماری لایه‌ای معکوس

در این فصل به بررسی معماری کلی مترجم معکوس ارائه شده می‌پردازیم و
معماری قبل از آن که به موفقیت نرسید را به همراه دلایل بررسی
می‌کنیم.

== معماری لایه‌ای در مترجم‌ها

به طور کلی همه مترجم‌های مدرن به صورت لایه‌ای عمل می‌کنند و هیچ مترجم صنعتی
به صورت تک‌عبوری از کد منبع کد زبان ماشین
نمی‌سازد. به صورت کلی مترجم‌های امروزی حداقل سه لایه زیر را دارند:

1. لایه پیشین: تجزیه ورودی
2. لایه میانی: بهینه‌سازی
3. لایه پسین: ساخت کد ماشین

در هر لایه کد منبع به صورت یک نمایش میانی در می‌آید و به لایه‌های بعدی فرستاده
می‌شود.

=== لایه پیشین
لایه پیشین وظیفه پردازش زبان سطح بالا و تبدیل آن به یک نمایش
میانی را دارد.
به‌عنوان مثال، کامپایلر Clang ابتدا کد C/C++ را تحلیل نحوی کرده، AST می‌سازد و سپس آن را به LLVM IR تبدیل می‌کند.

لایه پیشین مترجم‌ها معمولا شامل مراحل زیر است:
- تحلیل لغوی و نحوی (Lexing / Parsing)
- ساخت درخت نحو انتزاعی (AST)
- تحلیل معنایی و نوع‌دهی
- تولید LLVM IR

=== لایه میانی
بخش بهینه‌ساز یا لایه میانی روی نمایش میانی ساخته شده توسط لایه پیشین کار می‌کند.
در این مرحله، مجموعه‌ای از عبورها اجرا می‌شوند که هرکدام تحلیل یا تبدیل خاصی روی
نمایش میانی انجام می‌دهند.

ویژگی‌های متداول در طراحی عبورها:
- هر عبور به‌صورت مستقل از بقیه عبورها عمل می‌کند و می‌تواند فعال یا غیرفعال
  شود. اگرچه ممکن است یک عبور به اطلاعات به دست آمده از یک عبور تحلیلی دیگر
  نیاز داشته باشد.
- در هر عبور ممکن است به یک نوع بهنجار شده از نمایش میانی نیاز داشته باشیم
  و بعضی از بهینه‌سازی‌ها فقط روی این نوع کار کنند. در این صورت باید عبوری که این
  بهنجار سازی را انجام می‌دهد قبل از عبور فعلی انجام گرفته باشد.

نمونه‌هایی از عبورهایی که در اکثر مترجم‌ها پیاده‌سازی شده است:
- *Constant Propagation*
- *Dead Code Elimination*
- *Loop Invariant Code Motion*
- *Inlining*
- *Vectorization*

=== لایه پسین
بخش پسین وظیفه تولید کد ماشین برای معماری هدف را بر عهده دارد.
این بخش از طراحی ماژولار استفاده می‌کند و شامل اجزای زیر است:

- *TargetMachine*: رابط اصلی معماری هدف
- *TargetInstrInfo*: اطلاعات مربوط به دستورها
- *TargetRegisterInfo*: اطلاعات ثبات‌ها
- *TargetFrameLowering*: مدیریت پشته و پروتکل‌های تابع

مراحل کلی در backend:
1. انتخاب دستور (*Instruction Selection*) با استفاده از ساختار *SelectionDAG*
2. زمان‌بندی دستورها (*Instruction Scheduling*)
3. تخصیص ثبات‌ها (*Register Allocation*)
4. درج پیش‌کدها و پس‌کدهای تابع (*Prologue/Epilogue Insertion*)
5. بهینه‌سازی سطح ماشین (*Machine-level Peephole Optimizations*)
6. تولید اسمبلی یا کد باینری نهایی

== مزایای طراحی لایه‌ای

=== گسترش ساده به زبان‌ها و معماری های دیگر

شاهکار للوم

=== پیاده سازی راحت‌تر تحلیل‌ها روی نمایش میانی

== طراحی لایه‌ای مترجم معکوس

برای انجام دادن فرایند معکوس ترجمه، یک انتخاب طبیعی این است که ترجمه معکوس
دقیقا برعکس ترجمه عادی را طی کند. یعنی ابتدا کد ماشین به نمایش میانی مترجم
ترجمه معکوس شود، سپس چند عمل که معکوس عمل‌های بهینه‌سازی هستند مثل
de-inline
کردن توابع روی این نمایش میانی انجام شود، سپس کد سطح بالا از روی نمایش میانی
گسترش یافته تولید شود.

== مزایای طراحی لایه‌ای مترجم معکوس

طراحی لایه‌ای مترجم معکوس دقیقا همان مزایای طراحی لایه‌ای مترجم به مترجم می‌دهد را
به مترجم معکوس می‌دهد.

=== گسترش ساده به زبان‌ها و معماری‌های دیگر

اگرچه در این کار صرفا از زبان سی و معماری ریسک پنج پشتیبانی می‌شود اما معماری لایه‌ای
این امکان را می‌دهد تا در ادامه از معماری‌های دیگر مثل ایکس هشتاد و شش و از زبان‌های
دیگر مثل راسط نیز پشتیبانی شود.

=== پیاده‌سازی راحت‌تر تحلیل‌ها روی نمایش میانی

دلیل انتخاب رویکرد لایه‌ای و تغییر پیاده‌سازی قبلی این بود که امکان تحلیل عملیات‌ها
روی کد سطح بالا تقریبا وجود نداشت. برای
صحت‌سنجی و اعمال تغییرات در کد سطح بالا، پیچیدگی زیادی وجود داشت و همین پیچیدگی
باعث می‌شد تا پروژه به سمت انتخاب عمل‌های ساده‌تر و ضعیف‌تر متمایل شود که در نتیجه
باعث محدود شدن کیفیت خروجی شود.

با استفاده از معماری لایه‌ای و انجام بعضی از عملیات‌ها روی نمایش‌های میانی که ساده‌تر
هستند و با الگوریتم‌های شناخته شده تحلیل می‌شوند، می‌توان این مشکل را رفع کرد و
عملیات‌های پیجیده‌تری را برای کار للم‌ها تعریف کرد.

== پیاده‌سازی شکست خورده غیر لایه‌ای

قبل از معماری لایه‌ای فعلی، یک معماری ساده‌تر غیر لایه‌ای به کار گرفته می‌شد. در آن
معماری کد ماشین ورودی توسط یک مترجم معکوس الگوریتمی به یک کد به زبان سی ولی
ناخوانا تبدیل می‌شد و این کد سی به مدل زبانی ورودی داده می‌شد. برای مدل زبانی
چند عمل تعریف شده بود که همه عمل‌ها در دامنه زبان سی بودند و یک کد زبان سی
را به یک کد دیگر تبدیل می‌کردند.

برای تعیین این عمل‌ها و آزمون و خطا برای انتخاب عمل‌های خوب، که همان‌طور که
گفته شد تاثیر زیادی در عملکرد نهایی دارد، عمل‌های زیر امتحان شدند:

- افزودن نظر
- تغییر نام یک متغیر
- درون‌خط سازی یک مقداردهی
- حذف متغیر زائد
- تبدیل یک ورودی خوانده نشده به یک متغیر محلی
- تبدیل ضرب و شیفت به تقسیم
- تبدیل عدد به کاراکتر
- تبدیل پرش به حلقه
- درون‌خط سازی پرش
- تغییر نوع متغیر

در گام اول، انجام و بررسی درستی این عمل‌ها به خود مدل زبانی سپرده شد. مدل زبانی
متاسفانه در رعایت عمل‌ها و تولید خروجی متناسب با یک عمل موفق نبود و در یک
عمل کارهای دیگری را نیز انجام می‌داد و در بعضی مواقع کد را به کلی عوض می‌کرد. در
نتیجه حتی برای آزمایش این که مدل زبانی چقدر می‌تواند از این عمل‌ها به خوبی
استفاده کند نیازمند پیاده‌سازی الگوریتمی عملیات‌ها بودیم.

برای انجام یا صحت‌سنجی این عملیات‌ها، حتی عملیات‌هایی که نسبتا
ساده‌تر به نظر می‌رسند، روش‌های ساده متنی کافی نیست. مثلا برای پیاده‌سازی عمل تغییر
نام، نمی‌توان به صورت متنی همه نام‌ها را جایگزین کرد چون در زبان سی قابلیت
سایه‌کردن و استفاده مجدد از نام‌ها را می‌دهد و نام دوباره استفاده شده لزوما
نباید تغییر کند.

بنابراین برای انجام عمل‌ها به تحلیل‌های الگوریتمی نیاز داریم. همان‌طور که مطرح شد
تحلیل روی نمایش‌های میانی ساده تر است و در نتیجه در هر عمل، باید کد به نمایش‌های
ساده‌تر تبدیل شود و عمل روی آن نمایش‌ها انجام شود، و سپس مجددا کد از روی آن عملیات‌ها
ساخته شود.

#align(center, text(size: .8em, [

  #figure(
    image("../images/go_back_and_forth.drawio.svg", width: 80%),
  )

  *شکل 2:* انجام عملیات‌ها روی کد سی نیاز به جابه‌جایی مداوم بین کد
  سطح بالا و نمایش‌های میانی دارد.

]))

متاسفانه تبدیل کد سی سطح بالا به نمایش میانی قابل تحلیل یک عملیات بدون
از دست دادن داده نیست، و از نمایش میانی نمی‌توان به طور کامل
کد سطح بالای اصلی را بازیابی کرد. اگرچه تحقیقاتی برای انجام این کار
صورت گرفته است و در این زمینه کاربردهایی مثل انجام ریفاکتور در
محیط‌های توسعه و ابزارها وجود دارد، اما دقت این ابزارها محدود است
و بیشتر آن‌ها به دخالت یا نظارت
انسانی نیاز دارند. برای کاربرد مترجم معکوس نیازی به
این رفت و برگشت وجود ندارد. در مترجم معکوس ما از یک کد سطح پایین زبان
ماشین شروع می‌کنیم، و می‌توانیم به صورت مرحله به مرحله
این کار را انجام دهیم و در همان سطوح میانی عملیات‌ها را انجام دهیم و
بعد از انجام همه عملیات‌ها کد سطح بالا را بسازیم.

به طور خاص پیچیدگی انجام تبدیل‌های مرتبط با پرش باعث کنار گذاشته شدن این
روش و استفاده از روش لایه‌ای شد.
