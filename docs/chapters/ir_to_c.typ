#import "../notes.typ"

= تبدیل نمایش میانی به کد سی

تا به این نقطه به کمک عملیات‌های انجام شده ما یک نمایش میانی داریم که ساده‌سازی‌ها
و خواناسازی‌هایی روی آن انجام گرفته است اما هم چنان به صورت یک گراف جریان کنترل
ذخیره می‌شود. گراف جریان کنترل از پرش‌ها به عنوان ساختار کنترلی استفاده می‌کند ولی
در یک برنامه سطح بالا از دستورات کنترلی ساختاریافته مثل حلقه‌ها استفاده
می‌شود. در این بخش نمایش میانی را به یک کد سطح بالا به زبان سی تبدیل می‌کنیم و برای
این کار مهم‌ترین چالش تبدیل گراف جریان کنترل به یک برنامه محدود به ابزارهای
کنترلی ساختاریافته است.

== تبدیل به حالت ساختار یافته

زبان‌های سطح بالای اولیه از پرش‌ها به عنوان ابزار جریان کنترلی استفاده
می‌کردند، با این حال به مرور زمان جامعه کامپیوتر به این نتیجه رسید
که عدم استفاده از پرش‌ها و استفاده از ابزارهای جریان کنترلی ساختار یافته
مثل حلقه‌ها، شرط‌ها و توابع می‌تواند به خوانایی و توانایی استدلال درباره
کد کمک بسیاری کند.

اگرچه زبان سی از پرش‌ها پشتیبانی می‌کند و می‌توان نمایش میانی را به صورت
یک به یک به یک کد سی تبدیل کرد، اما این نوع کد سی یک کد خوانا نیست و
یک مترجم معکوس ایده‌آل باید به جای یک خروجی مبتنی بر پرش، یک خروجی
ساختاریافته ارائه دهد.

کنوث و فلانی ثابت کرده اند که تبدیل یک جریان کنترل با استفاده از پرش‌ها به یک جریان
کنترل ساختاریافته در حالت عمومی بدون افزایش هزینه زمان اجرا امکان پذیر نیست.

=== الگوریتم ریلوپر

در نسخه اولیه برای ساخت کد سی ابتدایی از
#notes.note[الگوریتم ریلوپر][Relooper]
استفاده شده بود. این الگوریتم یک الگوریتم ساخته شده برای کاربرد مترجم معکوس
نیست و اولین بار توسط سازنده
#notes.note[امسکریپتن][emscripten]
برای ایجاد کد
#notes.note[جاوا اسکریپت][javascript]
از روی نمایش میانی ‌ال‌ال‌وی‌ام است. هدف امسکریپتن ترجمه برنامه‌های
سی به جاوا اسکریپت (نه لزوما خوانا) برای اجرا در مرورگرهای وب
است. چون در زبان جاوا اسکریپت پرش دلخواه وجود ندارد، امسکریپتن
مجبور است تا جریان کنترل را به یک حالت ساخت یافته تبدیل کند.


=== استفاده از مدل زبانی

اگرچه الگوریتم ریلوپر می‌تواند در حالات ساده الگوهای ساختاریافته را تشخیص دهد
ولی در حالت عمومی از فالبک استفاده می‌کند که بسیار از کد سی اصلی می‌تواند دور
باشد.

برای انجام این تبدیل، مطابق با ایده کلی این پژوهش، از مدل زبانی برای ارائه یک
حالت ساختاریافته معادل کمک می‌گیریم و سپس به کمک یک الگوریتم معادل بودن الگوی
ارائه شده با جریان کنترل اصلی را بررسی می‌کنیم.

امکانی که به مدل زبانی داده می‌شود این است که در قالب یک زبان مخصوص دامنه بلوک‌های
ساده را در قالب یک سامانه کنترلی بچیند. یک مثال از یک چینش با این زبان را در
ادامه می‌بینیم:

```
bb0;
loop {
  if bb1 {
    bb2;
    continue;
  } else {
    bb3;
    return;
  }
}
```

وظیفه بررسی‌کننده این است که بررسی کند آیا این ساختار معادل کد ورودی داده شده به
مدل زبانی هست یا خیر. مثلا در مثال بالا خاتمه‌دهنده بلوک شماره صفر باید یک پرش به
بلوک‌ساده شماره یک باشد، خاتمه دهنده بلوک شماره یک باید یک پرش شرطی به یکی از
بلوک‌های دو یا سه باشد، خاتمه‌دهنده بلوک دو باید یک پرش به بلوک یک باشد و خاتمه‌دهنده
بلوک شماره سه باید بازگشت از تابع باشد.

استفاده از این زبان مخصوص دامنه به شدت به مدل زبانی در ارائه جریان کنترل ساختاریافته
صحیح کمک کرده است. قبل از استفاده از یک زبان، از مدل زبانی خواسته می‌شد تا رابطه‌ها
را به کمک خروجی جیسون به بررسی‌کننده وارد کند. در این حالت مشاهده می‌شد که اگرچه
مدل زبانی در افکارش توانسته است تا جریان کنترل صحیح را پیدا کند، اما در ارائه آن
دچار خطا می‌شود و در نتیجه خروجی توسط بررسی‌کننده پذیرفته نمی‌شود. با استفاده از
یک زبان نزدیک به هدف، مدل زبانی می‌تواند بهتر خروجی را منعکس کند و از اشتباهات
جزیی جلوگیری کند.

=== دستور زبان مخصوص دامنه توصیف جریان کنترل

در این بخش به بررسی دستور زبان رسمی زبان تعریف شده برای توصیف جریان کنترل ساختاریافته
می‌پردازیم.

```
ROOT := STATEMENT_LIST
STATEMENT_LIST := "" | STATEMENT STATEMENT_LIST
STATEMENT := SIMPLE_STATEMENT ";" | IF | LOOP | WHILE
SIMPLE_STATEMENT := BASIC_BLOCK | "continue" | "break"
IF := "if" BASIC_BLOCK BLOCK | "if" BASIC_BLOCK BLOCK "else" BLOCK
LOOP := "loop" BLOCK
WHILE := "while" BASIC_BLOCK BLOCK
BLOCK := "{" STATEMENT_LIST "}"
```

دستور زبان بالا نحوه پردازش زبان مخصوص دامنه ما را نشان می‌دهد. بررسی کننده وظیفه
بررسی شروط زیر را دارد:

- در هر فهرست دستور، خاتمه‌دهنده بلوک‌های ساده انتهای دستور قبل
  برابر با یک پرش به بلوک ساده ابتدای دستور بعد باشند.
- بلوک‌های ساده انتهای هر دستور به تفکیک نوع دستورات:
  - برای دستور شامل یک بلوک ساده، بلوک انتهایی تنها خود آن بلوک ساده است.
  - دستورهای ادامه و شکستن بلوک ساده انتهایی ندارند و هیچ دستوری بعد از آن‌ها
    مجاز نیست.
  - بلوک‌های ساده انتهای دستور شرط شامل اجتماع بلوک‌های ساده هر دو طرف شرط
    می‌شود.
  - بلوک‌های ساده انتهای دستور حلقه شامل همه بلوک‌های ساده‌ای می‌شود که قبل از
    دستور شکستن در درون این حلقه آمده اند.
- بلوک ساده ابتدای هر دستور به تفکیک نوع دستورها:
  - برای دستور شامل یک بلوک ساده، بلوک ابتدایی خود آن بلوک ساده است.
  - برای یک شرط یا حلقه شرطی، بلوک ابتدایی همان بلوک درون شرط است.
  - برای یک حلقه غیر شرطی، بلوک ابتدایی برابر بلوک ابتدایی اولین دستور حلقه
    است.
  - بلوک ابتدایی دستور ادامه همان بلوک ابتدایی حلقه است.
  - بلوک ابتدایی دستور شکستن همان بلوک ابتدایی اولین دستور بعد از حلقه است.
- خاتمه‌دهنده بلوک ساده به کار رفته درون یک شرط، باید یک پرش شرطی به دو
  بلوک ابتدایی دو دستور ابتدایی طرفین شرط باشد. اگر یکی از طرفین شرط هیچ
  دستوری نداشت، بلوک ابتدایی دستور بعد از شرط جایگزین آن می‌شود.
- بلوک ساده به کار رفته در یک حلقه شرطی، باید شرایط زیر را داشته باشد:
  - این بلوک‌ساده باید فقط یک خاتمه‌دهنده داشته باشد و هیچ دستوری نداشته باشد.
  - خاتمه‌دهنده آن باید یک پرش شرطی به بلوک ابتدایی دستور ابتدایی درون حلقه
    و بلوک ابتدایی دستور بعد از حلقه باشد.

با بررسی این شروط، می‌توان مطمئن شد که یک جریان کنترل ساختاریافته معادل را می‌توان
در زبان سی پیاده‌سازی کرد که از نظر اجرا معادل این نمایش میانی باشد. نسخه سی
ممکن است با نسخه ارائه شده در این زبان مخصوص دامنه تفاوت داشته باشد، مثلا بعضی
از شروط نقیض شوند یا دستورهای موجود در بلوک ساده یک شرط در بالای آن قرار
بگیرند، اما با این حال خروجی به مدل ارائه شده نزدیک خواهد بود و مهم تر از آن
حتما از ابزارهای کنترلی غیرساخت یافته مثل پرش استفاده نخواهد کرد.

=== تحمل‌پذیری خطاهای مدل زبانی

در صورتی که مدل زبانی جریان کنترلی را ارائه کرد که توسط بررسی‌کننده پذیرفته نشد، خطا
به صورت خوانا و با توضیح به مدل زبانی بازگردانده می‌شود تا آن را رفع کند. در صورتی
که مدل زبانی در پنج مرحله نتوانست مدل قابل قبولی را ارائه دهد، فرض می‌گیریم که
هیج نمایش ساختاریافته‌ای برای این جریان کنترلی وجود ندارد و ساخت کد سی را با الگوریتم
ریلوپر ادامه می‌دهیم.

== جانمایی تعریف متغیرها

در زبان سی می‌توان در هر نقطه‌ای از برنامه، یک متغیر تعریف کرد اما در نمایش میانی
همه متغیرها در ابتدای تابع تعریف شده اند. یک کد سی خوانا و نوشته شده توسط انسان
متغیرها را در بلوک مخصوص تعریف می‌کند.

اگرچه می‌توان برای این کار نیز از مدل زبانی استفاده کرد و جای متغیرها را از مدل
زبانی پرسید، اما بهترین جای مناسب برای یک متغیر معمولا درونی‌ترین جا است و
درونی‌ترین جا را می‌توان به کمک یک الگوریتم و بدون مدل زبانی محاسبه کرد.

بعد از انتقال کد به حالت ساختاریافته،
برای محاسبه بهترین جای تعریف یک متغیر، ابتدا تمام ارجاع‌های به این متغیر را
فهرست می‌کنیم. سپس از بلوک‌های ساختار یافته جریان کنترل
یک درخت می‌سازیم به طوری که پدر هر بلوک، بلوکی است که شامل این بلوک است. سپس
در این درخت بین همه ارجاع‌های این متغیر، کوچک‌ترین بلوکی که همه ارجاع‌ها درون
آن هستند را پیدا می‌کنیم. این بلوک، همان
#notes.note[پایین‌ترین جد مشترک][lowest common ancestor]
در درخت ساخته شده است.

بعد از پیدا کردن بلوک هدف، اولین ارجاع به این متغیر را پیدا می‌کنیم. در صورتی که
این ارجاع یک عملیات مقداردهی بود، تعریف متغیر را در همان مقداردهی انجام می‌دهیم. در
صورتی که عملیات خواندن این متغیر اولین عملیات بود، تعریف این متغیر را در ابتدای
تابع قرار می‌دهیم. این یک اقدام احتیاطی برای عدم تغییر معنای برنامه است. زیرا ممکن
است بلوک مذکور درون یک یا چند لایه حلقه باشد و مقدار خوانده شده به مقدار‌های قبلی
نوشته شده وابسته باشد. با وجود مقداردهی می‌توان تضمین کرد که مقدار این متغیر در
حلقه‌های قبل فاقد اهمیت است و تاثیری در رفتار برنامه ندارد.
