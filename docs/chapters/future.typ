#import "../notes.typ"

= کارهای پیشنهادی آینده

== بهبود‌های ممکن برای مترجم معکوس

=== پشتیبانی از نمادهای حذف شده

در برنامه‌هایی که می‌خواهند خود را اندکی نسبت به بدافزارها مقاوم کنند
یا حجم برنامه را کاهش دهند، نمادها را از باینری برنامه حذف می‌کنند. کد
فعلی ما برای تشخیص توابع از نمادها استفاده می‌کند و در نتیجه برای این نوع
برنامه‌ها اصلا کار نمی‌کند.

اما این مشکل بدون راه‌حل نیست و از روی پرش‌ها و دستورهای صدا زدن در زبان ماشین
می‌توان تشخیص داد که احتمالا یک موقعیت خاص از برنامه شروع یک تابع بوده است.

=== پشتیبانی از قراردادهای فراخوانی متفاوت

به علت این که این پژوهش روی دیتاست اگزه‌بنچ برای ارزیابی تمرکز کرده بود و این
دیتاست از فایل‌های تک تابعی زبان سی تشکیل شده بود و این فایل‌ها بعد از فرایند ترجمه
مجبور بودند که قرارداد فراخوانی استاندارد سی را استفاده کنند، در مترجم معکوس ما
فقط از این قرارداد پشتیبانی می‌شود.

اگرچه قرارداد فراخوانی استاندارد سی پر کاربرد ترین قرارداد استفاده شده برای
برنامه‌هاست و حتی زبان‌های دیگر نیز برای فراخوانی تابع‌های نوشته شده در سی یا سایر
زبان‌ها از این قرارداد فراخوانی استفاده می‌کنند، قراردادهای فراخوانی دیگری وجود
دارد که بقیه زبان‌ها از آن استفاده می‌کنند یا حتی مترجم‌های سی در مواقعی که یک تابع
به صورت محلی تعریف شده است و محدودیتی روی استاندارد بودن قرارداد فراخوانی آن
وجود ندارد، از قراردادهای فراخوانی اختصاصی خود که بهینه‌تر هستند استفاده می‌کنند.

=== پشتیبانی از زبان‌های به جز سی به عنوان زبان سطح بالای خروجی

می‌توان زبان‌های دیگر مثل راسط را نیز خروجی داد.

ممکن است هنگامی که زبان مبدا منطبق باشد بهتر کار کند.

چالش‌هایی وجود دارد، سی ساده است ولی زبان‌های دیگر سطح بالاتر هستند.

=== پشتیبانی از تابع‌های درون‌خط

به طور مشابه، به علت نبود نمونه‌های دارای چند تابع در
دیتاست مورد استفاده، هیچ تابع درون‌خطی نیز در دیتاست وجود
ندارد و در نتیجه
مترجم معکوس فعلی هیچ مکانیسمی برای تشخیص و بازسازی تابع‌هایی
که در زمان ترجمه درون‌خط شده‌اند ندارد.
چالش موجود در توابع درون‌خط این است که
در واقع، وقتی یک تابع در زمان کامپایل درون‌خط می‌شود، بدنه‌ی آن مستقیماً در محل فراخوانی کپی شده
و هیچ نشانه‌ای از مرز تابع در کد ماشین باقی نمی‌ماند. در نتیجه، ابزار مترجم معکوس ما
این بخش‌ها را به عنوان چند دستور متوالی در نظر می‌گیرد و قادر به بازسازی ساختار تابعی اصلی نخواهد بود.

برای حل این مشکل، مترجم‌های معکوس سنتی از چند روش استفاده می‌کنند، مثلا می‌توان
از تحلیل‌های پیشرفته‌تری مانند تشخیص الگوهای تکراری در کد ماشین
یا مقایسه‌ی بخش‌های مشابه در توابع مختلف استفاده کرد. با این حال
تشخیص توابع درون‌خط و بازیابی آن‌ها الگوریتم قطعی ندارد و بهترین
کار سپردن آن به مدل‌های زبانی بزرگ است. با افزودن یک عملیات که
از قسمتی از نمایش میانی یک تابع دیگر استخراج کند، می‌توان عمل
معکوس درون‌خط سازی را به قابلیت‌های مدل زبانی اضافه کرد و انتظار داشت
که توابع درون‌خط شده در کد ماشین به حالت اولیه خود برگردند.

=== استفاده از تحلیل تمام‌برنامه‌ای برای حذف ناهماهنگی‌های بین توابع

در نسخه‌ی فعلی مترجم معکوس، هر تابع به صورت مستقل تحلیل و بازگردانی می‌شود.
این موضوع باعث می‌شود که اطلاعات نوع داده‌ها، قراردادهای فراخوانی، و ساختارهای مشترک
(مانند ساختارهای داده‌ای عبوری بین توابع) ناهماهنگ و گاهی متناقض بازسازی شوند.
برای مثال، ممکن است در یک تابع مقدار برگشتی از نوع int فرض شود،
اما تابعی که آن را فراخوانی می‌کند انتظار مقدار double داشته باشد.

برای رفع چنین ناهماهنگی‌هایی، نیاز به یک مرحله‌ی تحلیل تمام‌برنامه‌ای وجود دارد
که در آن، تمام توابع و متغیرهای سراسری به عنوان یک گراف وابستگی بررسی شوند.
با استفاده از این گراف، می‌توان نوع داده‌ها و قراردادهای فراخوانی را به صورت استقرایی
در سراسر برنامه هماهنگ کرد. این مساله نه تنها باعث رفع ناسازگاری‌ها
و مشکلات ساخت برنامه چند تابعی می‌شود، بلکه احتمالا باعث افزایش کیفیت
خروجی حتی بدون در نظر گرفتن تابع‌های دیگر شود.

یک نسخه ساده از این روش می‌تواند دادن خلاصه‌ای از اطلاعات تمام برنامه
هنگام انتخاب امضای یک تابع باشد. اگرچه این کار تضمینی در سازگاری
بین تابعی ایجاد نمی‌کند، اما می‌تواند تا حد خوبی خطاهای از این قبیل
را رفع کند.

== استفاده از این روش برای تبدیل‌های بین دو زبان

روش پیشنهاد شده ترکیب مدل‌های زبانی بزرگ و استفاده از
روش‌های الگوریتمی و کامپایلری می‌تواند برای تبدیل خودکار دو زبان به هم نیز
استفاده شود. در یک پیاده‌سازی ساده اگر قابلیت چندین زبان خروجی به همین
پروژه اضافه شود، می‌توان کد را از یک زبان به زبان ماشین ترجمه‌کرد و سپس به
کمک این پروژه آن را به یک زبان ثانویه بازگردانی کرد.

اما یک ابزاری که به صورت تخصصی برای تبدیل بین دو زبان به کار می‌رود و وظیفه
ترجمه معکوس ندارد، نیازی نیست که کد را به اندازه زبان ماشین پایین بیاورد. این
ابزار می‌تواند کد را در سطح یک نمایش میانی که بسیاری از داده‌ها مثل نوع‌ها، اسامی
و نظرها را ذخیره کرده است پایین بیاورد و روی این نمایش به کمک مدل زبانی
عملیات‌های تبدیلی را انجام دهد و کد را به زبان مقصد تبدیل کند.

با توجه به نتایج به دست آمده در این پژوهش، تبدیل به یک نمایش میانی سطح
پایین تر و استفاده از مدل‌های زبانی روی این نمایش سطح پایین نسبت به
تبدیل یک مرحله‌ای به زبان مقصد و تلاش برای بهبود کد غیر
#notes.note[اصطلاحی][idiomatic]
به کمک مدل زبانی باعث ایجاد دشواری‌هایی هنگام بررسی صحت تغییرات ایجاد شده توسط مدل
زبانی خواهد شد.
